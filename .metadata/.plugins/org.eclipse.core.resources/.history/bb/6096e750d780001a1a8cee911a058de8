package com.tpsup.fileCopy;

// C:/a/b/*/d should return
//    C:/a/b/c1/d
//    C:/a/b/c2/d
// C:/a/b/*/nosuchfile should return C:/a/b/*/nosuchfile

import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class FileGlob {
    // this will be a static class: all methods are static
    public static Pattern HasGlobChar = Pattern.compile("[*?]");

    public static ArrayList<String> get(String pattern, HashMap<String, Object> opt) throws IOException {
        final ArrayList<String> results = new ArrayList<String>();
        // return the string if it is not pattern.
        {
            Matcher matcher = FileGlob.HasGlobChar.matcher(pattern);
            if (!matcher.find()) {
               results.add(pattern);
                return results;
            }
        }
        // convert \ to /. remove ending /
        pattern.replace("\\", "/").replace("/", "");
        // we need to start from the part without * or ?
        String[] parts = pattern.split("/");
        int full_length = parts.length;
        
        
        ArrayList<String> parsed = new ArrayList<String>();
        ArrayList<ArrayList<String>> todo = new ArrayList<ArrayList<String>>();
        ArrayList<String> seed = new ArrayList<String>();
        seed.add("/");
        todo.add(seed);
        while (true) {
            if (todo.isEmpty()) {
                break;
            }
            
            ArrayList<String> current = todo.remove(todo.size()-1);
            
            int current_length = current.size();
            
            String next_part = parts[current_length];           
            Matcher GlobCharMatcher = FileGlob.HasGlobChar.matcher(next_part);            
            if (GlobCharMatcher.find()) {
                // there is glob char in this pattern part
                
            } else {
                // no glob char in this pattern part
                current.add(next_part);
                
                String path = String.join("/",  current);
                if ((new File(path)).exists()) {
                    if (current.size() == full_length) {
                        results.add(path);
                    } else {
                        todo.add(current);
                    }
                } // else, this branch is discarded
            }
        }
    }
            
//        String NonGlobPart = "";
//        int i = 0;
//        for (String part : parts) {
//            i++;
//            if (part.isEmpty()) {
//                NonGlobPart += "/";
//                continue;
//            }
//            Matcher matcher = FileGlob.HasGlobChar.matcher(part);
//            if (matcher.find()) {
//                break;
//            }
//            NonGlobPart += part + "/";
//        }
//        // trim the last /
//        NonGlobPart = NonGlobPart.substring(0, NonGlobPart.length() - 1);
//        // https://docs.oracle.com/javase/tutorial/essential/io/find.html
//        final PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:" + pattern);
    public static void test () {
        File[] list = (new File("C:/users/william/github/tpsup/ps")).listFiles();
        if (list != null) {
            for (File f : list) {
                System.out.println(f.toString());
            }
        }
    }

    static void usage() {
        System.err.println("java FileGlob \"<glob_pattern>\"");
        System.err.println("java FileGlob \"C:/users/william/git*\"");
        System.exit(-1);
    }

    public static void main(String[] args) throws IOException {
        if (args.length != 1)
            usage();
        String pattern = args[0];
        //System.out.println((new FileGlob()).get(pattern, null).toString());
        test();
    }
}

