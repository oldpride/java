package com.tpsup.fileCopy;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.channels.SocketChannel;
import java.nio.file.FileSystems;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributeView;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.attribute.FileTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.StringUtils;
import javax.swing.JTextArea;

public class FileGlob {
    // this will be a static class: all methods are static
    public static Pattern HasGlobChar = Pattern.compile("[*?]");

    public static ArrayList<String> get(String pattern, HashMap<String, Object> opt) throws IOException {
        final ArrayList<String> results = new ArrayList<String>();
        // return the string if it is not pattern.
        {
            Matcher matcher = FileGlob.HasGlobChar.matcher(pattern);
            if (!matcher.find()) {
                results.add(pattern);
                return results;
            }
        }
        // convert \ to /. remove ending /
        pattern.replace("\\", "/").replace("/", "");
        // we need to start from the part without * or ?
        String[] array = pattern.split("/");
        String NonGlobPart = "";
        for (String part : array) {
            if (part.isEmpty()) {
                NonGlobPart += "/";
                continue;
            }
            Matcher matcher = FileGlob.HasGlobChar.matcher(part);
            if (matcher.find()) {
                break;
            }
            NonGlobPart += part + "/";
        }
        // trim the last /
        NonGlobPart = NonGlobPart.substring(0, NonGlobPart.length() - 1);
        // https://docs.oracle.com/javase/tutorial/essential/io/find.html
        // https://stackoverflow.com/questions/9148528/how-do-i-use-directory-globbing-in-jdk7
        final PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:" + pattern);
        Files.walkFileTree(Paths.get(NonGlobPart), new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException {
                if (matcher.matches(path)) {
                    // System.out.println(file);
                    results.add(path.toString());
                }
                return FileVisitResult.CONTINUE;
            }

            // Invoke the pattern matching
            // method on each directory.
            @Override
            public FileVisitResult preVisitDirectory(Path path, BasicFileAttributes attrs) {
                if (matcher.matches(path)) {
                    // System.out.println(file);
                    results.add(path.toString());
                }
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
                return FileVisitResult.CONTINUE;
            }
        });
        return results;
    }
        
    static void usage() {
        System.err.println("java FileGlob \"<glob_pattern>\"");
        System.err.println("java FileGlob \"C:/users/william/git*\"");
        System.exit(-1);
    }
    
        public static void main(String[] args)
                throws IOException {

                if (args.length != 1)
                    usage();

                String pattern = args[0];

                System.err.println((new FileGlob()).get(pattern, null).toString());
                
            }
}
    }
}